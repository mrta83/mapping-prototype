<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Texas Locations Prototype</title>
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: #f5f5f5;
      color: #1a1a1a;
    }

    .app {
      display: flex;
      height: 100vh;
    }

    /* Sidebar */
    .sidebar {
      width: 320px;
      background: white;
      border-right: 1px solid #e5e5e5;
      padding: 24px;
      overflow-y: auto;
      flex-shrink: 0;
    }

    .sidebar h1 {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .sidebar .subtitle {
      font-size: 13px;
      color: #666;
      margin-bottom: 24px;
    }

    .section {
      margin-bottom: 24px;
    }

    .section-title {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #999;
      margin-bottom: 12px;
    }

    .control-group {
      margin-bottom: 16px;
    }

    .control-group label {
      display: block;
      font-size: 13px;
      font-weight: 500;
      margin-bottom: 6px;
    }

    .control-group input[type="range"] {
      width: 100%;
      height: 4px;
      border-radius: 2px;
      background: #e5e5e5;
      outline: none;
      -webkit-appearance: none;
    }

    .control-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #3b82f6;
      cursor: pointer;
    }

    .control-group select {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #e5e5e5;
      border-radius: 6px;
      font-size: 13px;
      background: white;
      cursor: pointer;
    }

    .control-group input[type="text"] {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #e5e5e5;
      border-radius: 6px;
      font-size: 13px;
    }

    .value-display {
      font-size: 12px;
      color: #666;
      margin-top: 4px;
    }

    .btn-group {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .btn {
      padding: 8px 16px;
      border: 1px solid #e5e5e5;
      border-radius: 6px;
      background: white;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }

    .btn:hover {
      background: #f5f5f5;
    }

    .btn.active {
      background: #3b82f6;
      border-color: #3b82f6;
      color: white;
    }

    .btn.primary {
      background: #3b82f6;
      border-color: #3b82f6;
      color: white;
    }

    .btn.primary:hover {
      background: #2563eb;
    }

    /* Map Container */
    .map-container {
      flex: 1;
      position: relative;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    /* Stats Overlay */
    .stats {
      position: absolute;
      top: 16px;
      left: 16px;
      background: rgba(255,255,255,0.95);
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      font-size: 12px;
      z-index: 10;
    }

    .stats .stat {
      display: flex;
      justify-content: space-between;
      gap: 24px;
    }

    .stats .stat-value {
      font-weight: 600;
      color: #3b82f6;
    }

    /* Legend */
    .legend {
      position: absolute;
      bottom: 40px;
      left: 16px;
      background: rgba(255,255,255,0.95);
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      font-size: 11px;
      z-index: 10;
      min-width: 160px;
    }

    .legend-title {
      font-weight: 600;
      font-size: 12px;
      margin-bottom: 10px;
      color: #333;
      border-bottom: 1px solid #eee;
      padding-bottom: 6px;
    }

    .legend-section {
      margin-bottom: 10px;
    }

    .legend-section:last-child {
      margin-bottom: 0;
    }

    .legend-label {
      font-weight: 500;
      color: #666;
      margin-bottom: 6px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .legend-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 4px 0;
    }

    .legend-circle {
      border-radius: 50%;
      flex-shrink: 0;
      border: 1.5px solid white;
      box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }

    .legend-gradient {
      height: 10px;
      border-radius: 3px;
      margin: 4px 0;
      width: 100%;
    }

    .legend-gradient-labels {
      display: flex;
      justify-content: space-between;
      color: #666;
      font-size: 10px;
    }

    .legend-icon {
      font-size: 16px;
      line-height: 1;
    }

    .legend-text {
      color: #444;
    }

    /* Token Modal */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal.hidden {
      display: none;
    }

    .modal-content {
      background: white;
      padding: 32px;
      border-radius: 12px;
      max-width: 400px;
      width: 90%;
    }

    .modal-content h2 {
      font-size: 18px;
      margin-bottom: 8px;
    }

    .modal-content p {
      font-size: 13px;
      color: #666;
      margin-bottom: 16px;
    }

    .modal-content input {
      width: 100%;
      padding: 12px;
      border: 1px solid #e5e5e5;
      border-radius: 6px;
      font-size: 14px;
      margin-bottom: 16px;
    }

    .modal-content a {
      color: #3b82f6;
    }

    /* Color inputs */
    .color-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .color-row input[type="color"] {
      width: 32px;
      height: 32px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .color-row span {
      font-size: 12px;
      color: #666;
    }

    /* Checkbox styling */
    .control-group label input[type="checkbox"] {
      margin-right: 8px;
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .control-group label:has(input[type="checkbox"]) {
      display: flex;
      align-items: center;
      cursor: pointer;
      font-weight: 400;
    }

    /* Popup styling */
    .mapboxgl-popup-content {
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .popup-title {
      font-weight: 600;
      font-size: 14px;
      margin-bottom: 4px;
    }

    .popup-detail {
      font-size: 12px;
      color: #666;
    }
  </style>
</head>
<body>
  <!-- Token Modal -->
  <div id="tokenModal" class="modal hidden">
    <div class="modal-content">
      <h2>Mapbox Access Token</h2>
      <p>Enter your Mapbox public token to load the map. Get one free at <a href="https://account.mapbox.com/access-tokens/" target="_blank">mapbox.com</a></p>
      <input type="text" id="tokenInput" placeholder="pk.eyJ1Ijoi...">
      <button class="btn primary" onclick="saveToken()" style="width: 100%">Load Map</button>
    </div>
  </div>

  <div class="app">
    <aside class="sidebar">
      <h1>Texas Locations</h1>
      <p class="subtitle">Houston ¬∑ Dallas ¬∑ Austin ¬∑ San Antonio</p>

      <!-- Data Section -->
      <div class="section">
        <div class="section-title">Data</div>
        <div class="control-group">
          <label>Point Count</label>
          <input type="range" id="pointCount" min="10" max="10000" step="10" value="500" oninput="updatePointCount(this.value)">
          <div class="value-display"><span id="pointCountValue">500</span> points</div>
        </div>
        <div class="control-group">
          <label>Distribution</label>
          <select id="distribution" onchange="regenerateData()">
            <option value="clustered">Clustered (Neighborhoods)</option>
            <option value="uniform">Uniform (Spread)</option>
            <option value="route">I-35 Corridor</option>
            <option value="coastal">Houston Coast / City Loops</option>
          </select>
        </div>
        <div class="control-group">
          <label>Category Filter</label>
          <div class="btn-group" style="flex-wrap: wrap;">
            <button class="btn active" data-category="all" onclick="setCategoryFilter('all')">All</button>
            <button class="btn" data-category="Restaurant" onclick="setCategoryFilter('Restaurant')">Restaurant</button>
            <button class="btn" data-category="Shop" onclick="setCategoryFilter('Shop')">Shop</button>
            <button class="btn" data-category="Office" onclick="setCategoryFilter('Office')">Office</button>
            <button class="btn" data-category="Park" onclick="setCategoryFilter('Park')">Park</button>
            <button class="btn" data-category="Transit" onclick="setCategoryFilter('Transit')">Transit</button>
          </div>
        </div>
        <div class="control-group">
          <label>Volume Filter</label>
          <div class="btn-group">
            <button class="btn active" data-volume="all" onclick="setVolumeFilter('all')">All</button>
            <button class="btn" data-volume="small" onclick="setVolumeFilter('small')">1-3t</button>
            <button class="btn" data-volume="medium" onclick="setVolumeFilter('medium')">4-6t</button>
            <button class="btn" data-volume="large" onclick="setVolumeFilter('large')">7-10t</button>
          </div>
          <div class="value-display">Showing: <span id="filteredCount">500</span> locations</div>
        </div>
        <div class="control-group">
          <label>Region</label>
          <select id="region" onchange="changeRegion()">
            <option value="texas">Texas (All)</option>
            <option value="houston">Houston</option>
            <option value="dallas">Dallas-Fort Worth</option>
            <option value="austin">Austin</option>
            <option value="sanantonio">San Antonio</option>
          </select>
        </div>
        <button class="btn" onclick="regenerateData()" style="width: 100%">Regenerate Data</button>
      </div>

      <!-- Visualization Section -->
      <div class="section">
        <div class="section-title">Visualization</div>
        <div class="control-group">
          <label>Mode</label>
          <div class="btn-group">
            <button class="btn active" data-mode="clusters" onclick="setMode('clusters')">Clusters</button>
            <button class="btn" data-mode="heatmap" onclick="setMode('heatmap')">Heatmap</button>
            <button class="btn" data-mode="markers" onclick="setMode('markers')">Markers</button>
          </div>
        </div>
      </div>

      <!-- Cluster Settings -->
      <div class="section" id="clusterSettings">
        <div class="section-title">Cluster Settings</div>
        <div class="control-group">
          <label>Size Represents</label>
          <div class="btn-group">
            <button class="btn active" data-size-metric="count" onclick="setClusterSizeMetric('count')">Locations</button>
            <button class="btn" data-size-metric="weight" onclick="setClusterSizeMetric('weight')">Weight</button>
          </div>
        </div>
        <div class="control-group">
          <label>Color Represents</label>
          <div class="btn-group">
            <button class="btn" data-color-metric="count" onclick="setClusterColorMetric('count')">Locations</button>
            <button class="btn active" data-color-metric="weight" onclick="setClusterColorMetric('weight')">Avg Weight</button>
          </div>
        </div>
        <div class="control-group">
          <label>Cluster Radius</label>
          <input type="range" id="clusterRadius" min="20" max="100" value="50" oninput="updateClusterRadius(this.value)">
          <div class="value-display"><span id="clusterRadiusValue">50</span>px</div>
        </div>
        <div class="control-group">
          <label>Max Zoom</label>
          <input type="range" id="clusterMaxZoom" min="8" max="18" value="14" oninput="updateClusterMaxZoom(this.value)">
          <div class="value-display">Level <span id="clusterMaxZoomValue">14</span></div>
        </div>
        <div class="control-group">
          <label>Opacity</label>
          <input type="range" id="clusterOpacity" min="0.1" max="1" step="0.1" value="0.9" oninput="updateClusterOpacity(this.value)">
          <div class="value-display"><span id="clusterOpacityValue">0.9</span></div>
        </div>
      </div>

      <!-- Heatmap Settings -->
      <div class="section hidden" id="heatmapSettings">
        <div class="section-title">Heatmap Settings</div>
        <div class="control-group">
          <label>Heat Represents</label>
          <div class="btn-group">
            <button class="btn active" data-heat-metric="count" onclick="setHeatMetric('count')">Location Density</button>
            <button class="btn" data-heat-metric="weight" onclick="setHeatMetric('weight')">Total Weight</button>
          </div>
        </div>
        <div class="control-group">
          <label>Intensity</label>
          <input type="range" id="heatIntensity" min="0.1" max="2" step="0.1" value="1" oninput="updateHeatmap()">
          <div class="value-display"><span id="heatIntensityValue">1</span></div>
        </div>
        <div class="control-group">
          <label>Radius</label>
          <input type="range" id="heatRadius" min="5" max="50" value="20" oninput="updateHeatmap()">
          <div class="value-display"><span id="heatRadiusValue">20</span>px</div>
        </div>
        <div class="control-group">
          <label>Opacity</label>
          <input type="range" id="heatOpacity" min="0.1" max="1" step="0.1" value="0.8" oninput="updateHeatmap()">
          <div class="value-display"><span id="heatOpacityValue">0.8</span></div>
        </div>
      </div>

      <!-- Style Section -->
      <div class="section">
        <div class="section-title">Map Style</div>
        <div class="control-group">
          <select id="mapStyle" onchange="changeStyle()">
            <option value="light-v11">Light</option>
            <option value="dark-v11">Dark</option>
            <option value="streets-v12">Streets</option>
            <option value="satellite-streets-v12">Satellite</option>
            <option value="outdoors-v12">Outdoors</option>
            <option value="standard">3D Standard</option>
          </select>
        </div>
      </div>

      <!-- 3D Section -->
      <div class="section" id="threeDSettings">
        <div class="section-title">3D View</div>
        <div class="control-group">
          <label>Pitch (Tilt)</label>
          <input type="range" id="pitch" min="0" max="85" value="0" oninput="updatePitch(this.value)">
          <div class="value-display"><span id="pitchValue">0</span>¬∞</div>
        </div>
        <div class="control-group">
          <label>Bearing (Rotation)</label>
          <input type="range" id="bearing" min="-180" max="180" value="0" oninput="updateBearing(this.value)">
          <div class="value-display"><span id="bearingValue">0</span>¬∞</div>
        </div>
        <div class="control-group">
          <label>
            <input type="checkbox" id="show3DBuildings" onchange="toggle3DBuildings()">
            Show 3D Buildings
          </label>
        </div>
        <div class="control-group">
          <label>
            <input type="checkbox" id="show3DTerrain" onchange="toggle3DTerrain()">
            Show 3D Terrain
          </label>
        </div>
        <div class="control-group" id="terrainExaggeration" style="display: none;">
          <label>Terrain Exaggeration</label>
          <input type="range" id="exaggeration" min="0.5" max="3" step="0.1" value="1.5" oninput="updateExaggeration(this.value)">
          <div class="value-display"><span id="exaggerationValue">1.5</span>x</div>
        </div>
      </div>

      <!-- Colors Section -->
      <div class="section">
        <div class="section-title">Colors</div>
        <div class="control-group">
          <label>Primary Color</label>
          <div class="color-row">
            <input type="color" id="primaryColor" value="#3b82f6" onchange="updateColors()">
            <span id="primaryColorHex">#3b82f6</span>
          </div>
        </div>
        <div class="control-group">
          <label>Secondary Color</label>
          <div class="color-row">
            <input type="color" id="secondaryColor" value="#ef4444" onchange="updateColors()">
            <span id="secondaryColorHex">#ef4444</span>
          </div>
        </div>
      </div>

      <!-- Actions -->
      <div class="section">
        <div class="section-title">Actions</div>
        <div class="btn-group">
          <button class="btn" onclick="fitBounds()">Fit to Data</button>
          <button class="btn" onclick="resetView()">Reset View</button>
        </div>
      </div>
    </aside>

    <main class="map-container">
      <div id="map"></div>
      <div class="stats">
        <div class="stat">
          <span>Points:</span>
          <span class="stat-value" id="statPoints">0</span>
        </div>
        <div class="stat">
          <span>Visible:</span>
          <span class="stat-value" id="statVisible">0</span>
        </div>
        <div class="stat">
          <span>Zoom:</span>
          <span class="stat-value" id="statZoom">10</span>
        </div>
      </div>
      <div class="legend" id="legend">
        <!-- Legend content populated by JavaScript -->
      </div>
    </main>
  </div>

  <script>
    // =========================================
    // CONFIGURATION - Edit these for your needs
    // =========================================
    const REGIONS = {
      texas: { center: [-99.5, 31.0], zoom: 5.5, name: 'Texas (All)' },
      houston: { center: [-95.3698, 29.7604], zoom: 10, name: 'Houston' },
      dallas: { center: [-96.7970, 32.7767], zoom: 10, name: 'Dallas-Fort Worth' },
      austin: { center: [-97.7431, 30.2672], zoom: 11, name: 'Austin' },
      sanantonio: { center: [-98.4936, 29.4241], zoom: 11, name: 'San Antonio' }
    };

    // =========================================
    // STATE
    // =========================================
    let map;
    let currentMode = 'clusters';
    let currentData = [];
    let currentGeoJSON = null;  // Store GeoJSON for mode switching
    let popup;

    // Metric settings
    let clusterSizeMetric = 'count';   // 'count' or 'weight'
    let clusterColorMetric = 'weight'; // 'count' or 'weight'
    let heatMetric = 'count';          // 'count' or 'weight'

    // Filters
    let volumeFilter = 'all';    // 'all', 'small', 'medium', 'large'
    let categoryFilter = 'all';  // 'all', 'Restaurant', 'Shop', 'Office', 'Park', 'Transit'

    // =========================================
    // INITIALIZATION
    // =========================================
    function init() {
      const token = localStorage.getItem('mapbox_token');
      if (!token) {
        document.getElementById('tokenModal').classList.remove('hidden');
        return;
      }
      initMap(token);
    }

    function saveToken() {
      const token = document.getElementById('tokenInput').value.trim();
      if (token) {
        localStorage.setItem('mapbox_token', token);
        document.getElementById('tokenModal').classList.add('hidden');
        initMap(token);
      }
    }

    function initMap(token) {
      mapboxgl.accessToken = token;

      const region = REGIONS[document.getElementById('region').value];

      map = new mapboxgl.Map({
        container: 'map',
        style: `mapbox://styles/mapbox/${document.getElementById('mapStyle').value}`,
        center: region.center,
        zoom: region.zoom
      });

      map.addControl(new mapboxgl.NavigationControl(), 'top-right');
      map.addControl(new mapboxgl.ScaleControl(), 'bottom-right');

      popup = new mapboxgl.Popup({
        closeButton: false,
        closeOnClick: false
      });

      map.on('load', () => {
        // Load recycling bin icon
        loadRecyclingIcon();
        regenerateData();
      });

      map.on('zoom', updateStats);
      map.on('move', updateStats);
    }

    function loadRecyclingIcon() {
      // Create recycling bin SVG icon
      const svgString = `
        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">
          <!-- Bin body -->
          <rect x="6" y="10" width="20" height="18" rx="2" fill="#2E7D32" stroke="#1B5E20" stroke-width="1"/>
          <!-- Bin lid -->
          <rect x="4" y="7" width="24" height="4" rx="1" fill="#43A047" stroke="#2E7D32" stroke-width="1"/>
          <!-- Handle -->
          <rect x="13" y="4" width="6" height="4" rx="1" fill="#66BB6A"/>
          <!-- Recycling symbol -->
          <g transform="translate(16, 20)" fill="white">
            <path d="M-4,-5 L0,-8 L4,-5 L2,-5 L2,-2 L-2,-2 L-2,-5 Z" transform="rotate(0)"/>
            <path d="M-4,-5 L0,-8 L4,-5 L2,-5 L2,-2 L-2,-2 L-2,-5 Z" transform="rotate(120)"/>
            <path d="M-4,-5 L0,-8 L4,-5 L2,-5 L2,-2 L-2,-2 L-2,-5 Z" transform="rotate(240)"/>
          </g>
        </svg>
      `;

      const img = new Image(32, 32);
      img.onload = () => {
        if (!map.hasImage('recycling-bin')) {
          map.addImage('recycling-bin', img);
          console.log('Recycling bin icon loaded');
        }
      };
      img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgString);
    }

    // =========================================
    // DATA GENERATION
    // =========================================
    // Texas metro areas for multi-city distribution
    const TEXAS_METROS = [
      { name: 'Houston', center: [-95.3698, 29.7604], weight: 0.35, spread: 0.4 },
      { name: 'Dallas-Fort Worth', center: [-96.7970, 32.7767], weight: 0.30, spread: 0.5 },
      { name: 'San Antonio', center: [-98.4936, 29.4241], weight: 0.18, spread: 0.25 },
      { name: 'Austin', center: [-97.7431, 30.2672], weight: 0.17, spread: 0.2 }
    ];

    function generateData(count, distribution, region) {
      const r = REGIONS[region];
      const data = [];

      // For Texas-wide view, distribute across all metros
      const isTexasWide = region === 'texas';
      const spread = isTexasWide ? 0.3 : (region === 'dallas' ? 0.35 : 0.25);

      for (let i = 0; i < count; i++) {
        let lng, lat, metro = null;

        // For Texas-wide, pick a metro based on population weights
        if (isTexasWide) {
          const rand = Math.random();
          let cumulative = 0;
          for (const m of TEXAS_METROS) {
            cumulative += m.weight;
            if (rand < cumulative) {
              metro = m;
              break;
            }
          }
        }

        const baseCenter = metro ? metro.center : r.center;
        const baseSpread = metro ? metro.spread : spread;

        switch (distribution) {
          case 'clustered':
            // Create neighborhood clusters within the metro
            const clusterCount = 6 + Math.floor(Math.random() * 4);
            const clusterOffset = [
              (Math.random() - 0.5) * baseSpread,
              (Math.random() - 0.5) * baseSpread
            ];
            // Tighter clustering around cluster centers
            lng = baseCenter[0] + clusterOffset[0] + (Math.random() - 0.5) * baseSpread * 0.15;
            lat = baseCenter[1] + clusterOffset[1] + (Math.random() - 0.5) * baseSpread * 0.15;
            break;

          case 'uniform':
            lng = baseCenter[0] + (Math.random() - 0.5) * baseSpread * 2;
            lat = baseCenter[1] + (Math.random() - 0.5) * baseSpread * 2;
            break;

          case 'route':
            // Points along highways/corridors
            if (isTexasWide) {
              // I-35 corridor (San Antonio -> Austin -> Dallas)
              const t = Math.random();
              const i35Noise = (Math.random() - 0.5) * 0.15;
              if (t < 0.4) {
                // SA to Austin segment
                lng = -98.4936 + (t / 0.4) * 0.75 + i35Noise;
                lat = 29.4241 + (t / 0.4) * 0.85 + i35Noise * 0.5;
              } else {
                // Austin to Dallas segment
                const t2 = (t - 0.4) / 0.6;
                lng = -97.7431 + t2 * 0.95 + i35Noise;
                lat = 30.2672 + t2 * 2.5 + i35Noise * 0.5;
              }
            } else {
              // Radial highways from city center
              const angle = Math.random() * Math.PI * 2;
              const dist = Math.random() * baseSpread;
              const noise = (Math.random() - 0.5) * 0.02;
              lng = baseCenter[0] + Math.cos(angle) * dist + noise;
              lat = baseCenter[1] + Math.sin(angle) * dist + noise;
            }
            break;

          case 'coastal':
            if (region === 'houston' || isTexasWide) {
              // Houston: concentrate toward Gulf Coast / Ship Channel
              const coastBias = Math.random() * 0.7;
              lng = (metro || r).center[0] + coastBias * 0.5 + (Math.random() - 0.5) * 0.2;
              lat = (metro || r).center[1] - coastBias * 0.3 + (Math.random() - 0.5) * 0.15;
            } else {
              // Other cities: ring pattern (loop highways)
              const angle = Math.random() * Math.PI * 2;
              const dist = 0.08 + Math.random() * 0.12;
              lng = baseCenter[0] + Math.cos(angle) * dist;
              lat = baseCenter[1] + Math.sin(angle) * dist;
            }
            break;
        }

        data.push({
          id: i,
          lng: lng,
          lat: lat,
          value: Math.random() * 100,
          category: ['Restaurant', 'Shop', 'Office', 'Park', 'Transit'][Math.floor(Math.random() * 5)],
          metro: metro ? metro.name : r.name,
          recyclingVolume: Math.floor(Math.random() * 10) + 1  // 1-10 tons/month
        });
      }

      return data;
    }

    function regenerateData() {
      const count = parseInt(document.getElementById('pointCount').value);
      const distribution = document.getElementById('distribution').value;
      const region = document.getElementById('region').value;

      currentData = generateData(count, distribution, region);
      updateDataSource();
      updateStats();
    }

    function updateDataSource() {
      if (!map || !map.isStyleLoaded()) return;

      // Store GeoJSON for mode switching
      currentGeoJSON = {
        type: 'FeatureCollection',
        features: currentData.map(d => ({
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [d.lng, d.lat] },
          properties: {
            id: d.id,
            value: d.value,
            category: d.category,
            metro: d.metro,
            recyclingVolume: d.recyclingVolume
          }
        }))
      };

      // Remove existing layers and source
      removeAllLayers();

      // Add source with appropriate clustering based on mode
      const useCluster = currentMode === 'clusters';

      map.addSource('points', {
        type: 'geojson',
        data: currentGeoJSON,
        cluster: useCluster,
        clusterMaxZoom: parseInt(document.getElementById('clusterMaxZoom').value),
        clusterRadius: parseInt(document.getElementById('clusterRadius').value)
      });

      addLayers();
      document.getElementById('statPoints').textContent = currentData.length;
    }

    function removeAllLayers() {
      const layers = ['clusters', 'cluster-count', 'unclustered-point', 'heatmap', 'markers', 'markers-labels'];
      layers.forEach(id => {
        if (map.getLayer(id)) map.removeLayer(id);
      });
      if (map.getSource('points')) map.removeSource('points');
    }

    // =========================================
    // LAYERS
    // =========================================
    function addLayers() {
      const primary = document.getElementById('primaryColor').value;
      const secondary = document.getElementById('secondaryColor').value;

      if (currentMode === 'clusters') {
        // Determine size expression based on metric
        const sizeSteps = clusterSizeMetric === 'weight'
          ? [18, 20, 24, 50, 32, 100, 40]   // weight thresholds: 20t, 50t, 100t
          : [18, 10, 24, 50, 32, 100, 40];  // count thresholds: 10, 50, 100

        // Use coalesce for totalWeight to handle initial load
        const sizeValue = clusterSizeMetric === 'weight'
          ? ['coalesce', ['get', 'totalWeight'], ['*', ['get', 'point_count'], 5]]
          : ['get', 'point_count'];

        // Determine color expression based on metric
        // For color, we can use average weight (totalWeight / point_count) or just count
        let colorExpression;
        if (clusterColorMetric === 'weight') {
          // Color by average weight per location
          // Use coalesce to handle cases where totalWeight isn't ready yet
          colorExpression = [
            'interpolate', ['linear'],
            ['/',
              ['coalesce', ['get', 'totalWeight'], ['*', ['get', 'point_count'], 5]], // fallback: assume 5 tons avg
              ['get', 'point_count']
            ],
            1, primary,      // 1 ton avg = primary
            5, mixColors(primary, secondary, 0.5),  // 5 tons avg = mid
            10, secondary    // 10 tons avg = secondary
          ];
        } else {
          // Color by count
          colorExpression = [
            'step', ['get', 'point_count'],
            primary, 10,
            mixColors(primary, secondary, 0.3), 50,
            mixColors(primary, secondary, 0.6), 100,
            secondary
          ];
        }

        // Cluster circles
        const clusterOpacity = parseFloat(document.getElementById('clusterOpacity').value);

        map.addLayer({
          id: 'clusters',
          type: 'circle',
          source: 'points',
          filter: ['has', 'point_count'],
          paint: {
            'circle-color': colorExpression,
            'circle-radius': [
              'step', sizeValue,
              ...sizeSteps
            ],
            'circle-opacity': clusterOpacity,
            'circle-stroke-width': 2,
            'circle-stroke-color': '#fff'
          }
        });

        // Cluster labels - show both count and weight
        map.addLayer({
          id: 'cluster-count',
          type: 'symbol',
          source: 'points',
          filter: ['has', 'point_count'],
          layout: {
            'text-field': [
              'concat',
              ['get', 'point_count'], ' ¬∑ ',
              ['number-format',
                ['coalesce', ['get', 'totalWeight'], ['*', ['get', 'point_count'], 5]],
                { 'max-fraction-digits': 0 }
              ], 't'
            ],
            'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
            'text-size': 11
          },
          paint: {
            'text-color': '#fff'
          }
        });

        // Unclustered points (shown at high zoom when clusters break apart)
        map.addLayer({
          id: 'unclustered-point',
          type: 'circle',
          source: 'points',
          filter: ['!', ['has', 'point_count']],
          paint: {
            'circle-color': primary,
            'circle-radius': [
              'interpolate', ['linear'], ['get', 'recyclingVolume'],
              1, 4,
              10, 10
            ],
            'circle-opacity': clusterOpacity,
            'circle-stroke-width': 2,
            'circle-stroke-color': '#fff'
          }
        });

      } else if (currentMode === 'heatmap') {
        // Heatmap layer
        const intensity = parseFloat(document.getElementById('heatIntensity').value);
        const radius = parseInt(document.getElementById('heatRadius').value);
        const opacity = parseFloat(document.getElementById('heatOpacity').value);

        // Weight by recycling volume or count (1)
        const weightExpression = heatMetric === 'weight'
          ? ['interpolate', ['linear'], ['get', 'recyclingVolume'], 1, 0.1, 10, 1]
          : 1;

        map.addLayer({
          id: 'heatmap',
          type: 'heatmap',
          source: 'points',
          paint: {
            'heatmap-weight': weightExpression,
            'heatmap-intensity': intensity,
            'heatmap-color': [
              'interpolate',
              ['linear'],
              ['heatmap-density'],
              0, 'rgba(0,0,255,0)',
              0.1, 'royalblue',
              0.3, 'cyan',
              0.5, 'lime',
              0.7, 'yellow',
              1, 'red'
            ],
            'heatmap-radius': radius,
            'heatmap-opacity': opacity
          }
        });

        console.log('Heatmap layer added:', { intensity, radius, opacity, metric: heatMetric });

      } else if (currentMode === 'markers') {
        // Individual markers with recycling bin icons
        map.addLayer({
          id: 'markers',
          type: 'symbol',
          source: 'points',
          layout: {
            'icon-image': 'recycling-bin',
            'icon-size': [
              'interpolate', ['linear'], ['get', 'recyclingVolume'],
              1, 0.6,   // 1 ton = small
              5, 0.9,   // 5 tons = medium
              10, 1.2   // 10 tons = large
            ],
            'icon-allow-overlap': true,
            'icon-anchor': 'bottom'
          }
        });

        // Add volume labels below icons at higher zoom
        map.addLayer({
          id: 'markers-labels',
          type: 'symbol',
          source: 'points',
          minzoom: 12,
          layout: {
            'text-field': ['concat', ['get', 'recyclingVolume'], 't'],
            'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
            'text-size': 10,
            'text-offset': [0, 0.8],
            'text-anchor': 'top'
          },
          paint: {
            'text-color': '#1B5E20',
            'text-halo-color': '#fff',
            'text-halo-width': 1.5
          }
        });
      }

      setupLayerInteractions();
      updateLegend();
    }

    // =========================================
    // MODE SWITCHING
    // =========================================
    function setMode(mode) {
      const prevMode = currentMode;
      currentMode = mode;

      // Update buttons
      document.querySelectorAll('[data-mode]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === mode);
      });

      // Show/hide settings panels
      document.getElementById('clusterSettings').classList.toggle('hidden', mode !== 'clusters');
      document.getElementById('heatmapSettings').classList.toggle('hidden', mode !== 'heatmap');

      // Rebuild layers if we have data
      if (map && currentGeoJSON) {
        rebuildForMode();
      }
    }

    function rebuildForMode() {
      if (!map || !map.isStyleLoaded() || !currentGeoJSON) return;

      // Remove existing layers and source
      removeAllLayers();

      // Get filtered data based on volume filter
      const filteredData = getFilteredGeoJSON();

      // Add source - only cluster for clusters mode
      const useCluster = currentMode === 'clusters';

      const sourceConfig = {
        type: 'geojson',
        data: filteredData,
        cluster: useCluster,
        clusterMaxZoom: parseInt(document.getElementById('clusterMaxZoom').value),
        clusterRadius: parseInt(document.getElementById('clusterRadius').value)
      };

      // Add cluster aggregation properties when clustering
      if (useCluster) {
        sourceConfig.clusterProperties = {
          // Sum of recycling volume for all points in cluster
          totalWeight: ['+', ['get', 'recyclingVolume']],
          // For calculating average, we need sum and count
          // count is automatic via point_count
        };
      }

      map.addSource('points', sourceConfig);

      addLayers();
    }

    function updateLegend() {
      const legend = document.getElementById('legend');
      const primary = document.getElementById('primaryColor').value;
      const secondary = document.getElementById('secondaryColor').value;

      let html = '';

      // Filter indicator
      const volumeLabels = {
        'all': 'All volumes',
        'small': '1-3t',
        'medium': '4-6t',
        'large': '7-10t'
      };

      const activeFilters = [];
      if (categoryFilter !== 'all') activeFilters.push(categoryFilter);
      if (volumeFilter !== 'all') activeFilters.push(volumeLabels[volumeFilter]);

      const filterHtml = activeFilters.length > 0
        ? `<div class="legend-section" style="background: #f0f9ff; margin: -12px -16px 10px -16px; padding: 8px 16px; border-radius: 8px 8px 0 0;">
            <div class="legend-text" style="color: #0369a1; font-weight: 500;">üîç ${activeFilters.join(' + ')}</div>
           </div>`
        : '';

      if (currentMode === 'clusters') {
        html = `
          ${filterHtml}
          <div class="legend-title">Clusters</div>
          <div class="legend-section">
            <div class="legend-label">Size: ${clusterSizeMetric === 'weight' ? 'Total Weight' : 'Location Count'}</div>
            <div class="legend-row">
              <div class="legend-circle" style="width: 14px; height: 14px; background: ${primary};"></div>
              <span class="legend-text">${clusterSizeMetric === 'weight' ? '< 20 tons' : '< 10 locations'}</span>
            </div>
            <div class="legend-row">
              <div class="legend-circle" style="width: 20px; height: 20px; background: ${primary};"></div>
              <span class="legend-text">${clusterSizeMetric === 'weight' ? '20-50 tons' : '10-50 locations'}</span>
            </div>
            <div class="legend-row">
              <div class="legend-circle" style="width: 28px; height: 28px; background: ${primary};"></div>
              <span class="legend-text">${clusterSizeMetric === 'weight' ? '> 100 tons' : '> 100 locations'}</span>
            </div>
          </div>
          <div class="legend-section">
            <div class="legend-label">Color: ${clusterColorMetric === 'weight' ? 'Avg Weight/Location' : 'Location Count'}</div>
            <div class="legend-gradient" style="background: linear-gradient(to right, ${primary}, ${secondary});"></div>
            <div class="legend-gradient-labels">
              <span>${clusterColorMetric === 'weight' ? '1 ton' : 'Few'}</span>
              <span>${clusterColorMetric === 'weight' ? '10 tons' : 'Many'}</span>
            </div>
          </div>
          <div class="legend-section">
            <div class="legend-label">Label Format</div>
            <div class="legend-text" style="font-size: 10px; color: #888;">count ¬∑ total weight</div>
            <div class="legend-text" style="font-family: monospace;">42 ¬∑ 156t</div>
          </div>
        `;
      } else if (currentMode === 'heatmap') {
        html = `
          ${filterHtml}
          <div class="legend-title">Heatmap</div>
          <div class="legend-section">
            <div class="legend-label">${heatMetric === 'weight' ? 'Total Weight Density' : 'Location Density'}</div>
            <div class="legend-gradient" style="background: linear-gradient(to right, rgba(0,0,255,0.3), cyan, lime, yellow, red);"></div>
            <div class="legend-gradient-labels">
              <span>Low</span>
              <span>High</span>
            </div>
          </div>
          <div class="legend-section">
            <div class="legend-text" style="font-size: 10px; color: #666;">
              ${heatMetric === 'weight'
                ? 'Intensity weighted by recycling volume (tons/month)'
                : 'Each location weighted equally'}
            </div>
          </div>
        `;
      } else if (currentMode === 'markers') {
        html = `
          ${filterHtml}
          <div class="legend-title">Recycling Locations</div>
          <div class="legend-section">
            <div class="legend-label">Volume (tons/month)</div>
            <div class="legend-row">
              <span class="legend-icon" style="font-size: 12px;">üóëÔ∏è</span>
              <span class="legend-text">1-3 tons (small)</span>
            </div>
            <div class="legend-row">
              <span class="legend-icon" style="font-size: 16px;">üóëÔ∏è</span>
              <span class="legend-text">4-6 tons (medium)</span>
            </div>
            <div class="legend-row">
              <span class="legend-icon" style="font-size: 20px;">üóëÔ∏è</span>
              <span class="legend-text">7-10 tons (large)</span>
            </div>
          </div>
          <div class="legend-section">
            <div class="legend-text" style="font-size: 10px; color: #666;">
              Labels show volume at zoom 12+
            </div>
          </div>
        `;
      }

      legend.innerHTML = html;
    }

    function setupLayerInteractions() {
      // Cluster click to zoom
      if (map.getLayer('clusters')) {
        map.on('click', 'clusters', (e) => {
          const features = map.queryRenderedFeatures(e.point, { layers: ['clusters'] });
          if (!features.length) return;
          const clusterId = features[0].properties.cluster_id;

          map.getSource('points').getClusterExpansionZoom(clusterId, (err, zoom) => {
            if (err) return;
            map.easeTo({
              center: features[0].geometry.coordinates,
              zoom: zoom
            });
          });
        });

        map.on('mouseenter', 'clusters', () => {
          map.getCanvas().style.cursor = 'pointer';
        });

        map.on('mouseleave', 'clusters', () => {
          map.getCanvas().style.cursor = '';
        });
      }

      // Point hover for unclustered-point or markers
      const pointLayer = map.getLayer('unclustered-point') ? 'unclustered-point' :
                         map.getLayer('markers') ? 'markers' : null;

      if (pointLayer) {
        map.on('mouseenter', pointLayer, (e) => {
          map.getCanvas().style.cursor = 'pointer';
          const coords = e.features[0].geometry.coordinates.slice();
          const props = e.features[0].properties;

          popup.setLngLat(coords)
            .setHTML(`
              <div class="popup-title">${props.category}</div>
              <div class="popup-detail">${props.metro}</div>
              <div class="popup-detail">‚ôªÔ∏è <strong>${props.recyclingVolume} tons</strong>/month</div>
            `)
            .addTo(map);
        });

        map.on('mouseleave', pointLayer, () => {
          map.getCanvas().style.cursor = '';
          popup.remove();
        });
      }
    }

    // =========================================
    // CONTROLS
    // =========================================
    function updatePointCount(value) {
      document.getElementById('pointCountValue').textContent = value;
    }

    // Category filter control
    function setCategoryFilter(filter) {
      categoryFilter = filter;
      document.querySelectorAll('[data-category]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.category === filter);
      });
      if (map && currentGeoJSON) {
        rebuildForMode();
      }
    }

    // Volume filter control
    function setVolumeFilter(filter) {
      volumeFilter = filter;
      document.querySelectorAll('[data-volume]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.volume === filter);
      });
      if (map && currentGeoJSON) {
        rebuildForMode();
      }
    }

    function getFilteredGeoJSON() {
      if (!currentGeoJSON) return null;

      let features = currentGeoJSON.features;

      // Apply category filter
      if (categoryFilter !== 'all') {
        features = features.filter(f => f.properties.category === categoryFilter);
      }

      // Apply volume filter
      if (volumeFilter !== 'all') {
        let min, max;
        switch (volumeFilter) {
          case 'small':  min = 1; max = 3; break;
          case 'medium': min = 4; max = 6; break;
          case 'large':  min = 7; max = 10; break;
          default: min = 1; max = 10;
        }
        features = features.filter(f =>
          f.properties.recyclingVolume >= min && f.properties.recyclingVolume <= max
        );
      }

      updateFilteredCount(features.length);

      return {
        type: 'FeatureCollection',
        features: features
      };
    }

    function updateFilteredCount(count) {
      document.getElementById('filteredCount').textContent = count;
    }

    // Cluster metric controls
    function setClusterSizeMetric(metric) {
      clusterSizeMetric = metric;
      document.querySelectorAll('[data-size-metric]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.sizeMetric === metric);
      });
      if (map && currentGeoJSON && currentMode === 'clusters') {
        rebuildForMode();
      }
    }

    function setClusterColorMetric(metric) {
      clusterColorMetric = metric;
      document.querySelectorAll('[data-color-metric]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.colorMetric === metric);
      });
      if (map && currentGeoJSON && currentMode === 'clusters') {
        rebuildForMode();
      }
    }

    // Heatmap metric control
    function setHeatMetric(metric) {
      heatMetric = metric;
      document.querySelectorAll('[data-heat-metric]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.heatMetric === metric);
      });
      if (map && currentGeoJSON && currentMode === 'heatmap') {
        rebuildForMode();
      }
    }

    function updateClusterRadius(value) {
      document.getElementById('clusterRadiusValue').textContent = value;
      if (map && currentGeoJSON) {
        rebuildForMode();
      }
    }

    function updateClusterMaxZoom(value) {
      document.getElementById('clusterMaxZoomValue').textContent = value;
      if (map && currentGeoJSON) {
        rebuildForMode();
      }
    }

    function updateClusterOpacity(value) {
      document.getElementById('clusterOpacityValue').textContent = value;
      const opacity = parseFloat(value);

      if (map) {
        if (map.getLayer('clusters')) {
          map.setPaintProperty('clusters', 'circle-opacity', opacity);
        }
        if (map.getLayer('unclustered-point')) {
          map.setPaintProperty('unclustered-point', 'circle-opacity', opacity);
        }
      }
    }

    function updateHeatmap() {
      const intensity = parseFloat(document.getElementById('heatIntensity').value);
      const radius = parseInt(document.getElementById('heatRadius').value);
      const opacity = parseFloat(document.getElementById('heatOpacity').value);

      document.getElementById('heatIntensityValue').textContent = intensity;
      document.getElementById('heatRadiusValue').textContent = radius;
      document.getElementById('heatOpacityValue').textContent = opacity;

      if (map && map.getLayer('heatmap')) {
        map.setPaintProperty('heatmap', 'heatmap-intensity', intensity);
        map.setPaintProperty('heatmap', 'heatmap-radius', radius);
        map.setPaintProperty('heatmap', 'heatmap-opacity', opacity);
      }
    }

    function updateColors() {
      const primary = document.getElementById('primaryColor').value;
      const secondary = document.getElementById('secondaryColor').value;

      document.getElementById('primaryColorHex').textContent = primary;
      document.getElementById('secondaryColorHex').textContent = secondary;

      if (!map) return;

      // Update cluster layers if they exist
      if (map.getLayer('clusters')) {
        map.setPaintProperty('clusters', 'circle-color', [
          'step', ['get', 'point_count'],
          primary, 10,
          mixColors(primary, secondary, 0.3), 50,
          mixColors(primary, secondary, 0.6), 100,
          secondary
        ]);
      }

      if (map.getLayer('unclustered-point')) {
        map.setPaintProperty('unclustered-point', 'circle-color', primary);
      }

      // Update heatmap if it exists
      if (map.getLayer('heatmap')) {
        map.setPaintProperty('heatmap', 'heatmap-color', [
          'interpolate', ['linear'], ['heatmap-density'],
          0, 'rgba(0,0,0,0)',
          0.2, primary + '40',
          0.4, primary + '80',
          0.6, mixColors(primary, secondary, 0.5),
          0.8, secondary + 'cc',
          1, secondary
        ]);
      }

      // Update legend to reflect new colors
      updateLegend();
    }

    function changeStyle() {
      const style = document.getElementById('mapStyle').value;

      // Handle 3D standard style differently
      if (style === 'standard') {
        map.setStyle('mapbox://styles/mapbox/standard');
      } else {
        map.setStyle(`mapbox://styles/mapbox/${style}`);
      }

      map.once('style.load', () => {
        // Reload custom icons (cleared on style change)
        loadRecyclingIcon();

        // Small delay to ensure icon is loaded before rebuilding layers
        setTimeout(() => {
          if (currentGeoJSON) {
            rebuildForMode();
          }
          // Re-apply 3D features if enabled
          if (document.getElementById('show3DBuildings').checked) {
            add3DBuildings();
          }
          if (document.getElementById('show3DTerrain').checked) {
            add3DTerrain();
          }
        }, 100);
      });
    }

    // =========================================
    // 3D CONTROLS
    // =========================================
    function updatePitch(value) {
      document.getElementById('pitchValue').textContent = value;
      if (map) {
        map.easeTo({ pitch: parseFloat(value), duration: 300 });
      }
    }

    function updateBearing(value) {
      document.getElementById('bearingValue').textContent = value;
      if (map) {
        map.easeTo({ bearing: parseFloat(value), duration: 300 });
      }
    }

    function toggle3DBuildings() {
      const show = document.getElementById('show3DBuildings').checked;
      if (show) {
        add3DBuildings();
        // Set a nice pitch if currently flat
        if (map.getPitch() < 30) {
          map.easeTo({ pitch: 45, duration: 500 });
          document.getElementById('pitch').value = 45;
          document.getElementById('pitchValue').textContent = '45';
        }
      } else {
        remove3DBuildings();
      }
    }

    function add3DBuildings() {
      if (!map || map.getLayer('3d-buildings')) return;

      // Find the first symbol layer to insert buildings below labels
      const layers = map.getStyle().layers;
      let labelLayerId;
      for (const layer of layers) {
        if (layer.type === 'symbol' && layer.layout['text-field']) {
          labelLayerId = layer.id;
          break;
        }
      }

      map.addLayer({
        id: '3d-buildings',
        source: 'composite',
        'source-layer': 'building',
        filter: ['==', 'extrude', 'true'],
        type: 'fill-extrusion',
        minzoom: 12,
        paint: {
          'fill-extrusion-color': [
            'interpolate',
            ['linear'],
            ['get', 'height'],
            0, '#e0e0e0',
            50, '#c0c0c0',
            100, '#a0a0a0',
            200, '#808080'
          ],
          'fill-extrusion-height': ['get', 'height'],
          'fill-extrusion-base': ['get', 'min_height'],
          'fill-extrusion-opacity': 0.8
        }
      }, labelLayerId);

      console.log('3D buildings layer added');
    }

    function remove3DBuildings() {
      if (map && map.getLayer('3d-buildings')) {
        map.removeLayer('3d-buildings');
        console.log('3D buildings layer removed');
      }
    }

    function toggle3DTerrain() {
      const show = document.getElementById('show3DTerrain').checked;
      if (show) {
        add3DTerrain();
        document.getElementById('terrainExaggeration').style.display = 'block';
        // Set a nice pitch if currently flat
        if (map.getPitch() < 30) {
          map.easeTo({ pitch: 50, duration: 500 });
          document.getElementById('pitch').value = 50;
          document.getElementById('pitchValue').textContent = '50';
        }
      } else {
        remove3DTerrain();
        document.getElementById('terrainExaggeration').style.display = 'none';
      }
    }

    function add3DTerrain() {
      if (!map) return;

      // Add terrain source if not present
      if (!map.getSource('mapbox-dem')) {
        map.addSource('mapbox-dem', {
          type: 'raster-dem',
          url: 'mapbox://mapbox.mapbox-terrain-dem-v1',
          tileSize: 512,
          maxzoom: 14
        });
      }

      // Enable terrain
      map.setTerrain({
        source: 'mapbox-dem',
        exaggeration: parseFloat(document.getElementById('exaggeration').value)
      });

      // Add sky layer for nice horizon
      if (!map.getLayer('sky')) {
        map.addLayer({
          id: 'sky',
          type: 'sky',
          paint: {
            'sky-type': 'atmosphere',
            'sky-atmosphere-sun': [0.0, 90.0],
            'sky-atmosphere-sun-intensity': 15
          }
        });
      }

      console.log('3D terrain enabled');
    }

    function remove3DTerrain() {
      if (!map) return;

      map.setTerrain(null);

      if (map.getLayer('sky')) {
        map.removeLayer('sky');
      }

      console.log('3D terrain disabled');
    }

    function updateExaggeration(value) {
      document.getElementById('exaggerationValue').textContent = value;
      if (map && map.getTerrain()) {
        map.setTerrain({
          source: 'mapbox-dem',
          exaggeration: parseFloat(value)
        });
      }
    }

    function changeRegion() {
      const region = REGIONS[document.getElementById('region').value];
      map.flyTo({
        center: region.center,
        zoom: region.zoom,
        duration: 1500
      });
      regenerateData();
    }

    function fitBounds() {
      if (currentData.length === 0) return;

      const bounds = new mapboxgl.LngLatBounds();
      currentData.forEach(d => bounds.extend([d.lng, d.lat]));

      map.fitBounds(bounds, { padding: 50 });
    }

    function resetView() {
      const region = REGIONS[document.getElementById('region').value];
      map.flyTo({
        center: region.center,
        zoom: region.zoom,
        duration: 1000
      });
    }

    function updateStats() {
      if (!map) return;

      const zoom = map.getZoom().toFixed(1);
      document.getElementById('statZoom').textContent = zoom;

      // Count visible features
      const features = map.queryRenderedFeatures({ layers: ['unclustered-point', 'clusters'].filter(l => map.getLayer(l)) });
      document.getElementById('statVisible').textContent = features.length;
    }

    // =========================================
    // UTILITIES
    // =========================================
    function mixColors(color1, color2, ratio) {
      const hex = (c) => parseInt(c.slice(1), 16);
      const r = (h) => (h >> 16) & 255;
      const g = (h) => (h >> 8) & 255;
      const b = (h) => h & 255;

      const h1 = hex(color1);
      const h2 = hex(color2);

      const nr = Math.round(r(h1) * (1 - ratio) + r(h2) * ratio);
      const ng = Math.round(g(h1) * (1 - ratio) + g(h2) * ratio);
      const nb = Math.round(b(h1) * (1 - ratio) + b(h2) * ratio);

      return `#${((1 << 24) + (nr << 16) + (ng << 8) + nb).toString(16).slice(1)}`;
    }

    // Initialize on load
    init();
  </script>
</body>
</html>
